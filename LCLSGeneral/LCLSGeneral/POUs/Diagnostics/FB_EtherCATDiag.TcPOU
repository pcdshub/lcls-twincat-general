<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_EtherCATDiag" Id="{4742d405-d1cb-49f3-8224-ceacd75d7213}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_EtherCATDiag
VAR_INPUT
    sIPCNetID					: T_AmsNetId; 	// AmsNetId of the IPC
    sMasterNetID				: T_AmsNetId; 	// AmsNetId of the EtherCAT master device
    nMasterDevID				: UINT;			// Device ID of EtherCAT master
    nSlaveCount 				: UINT;			// current slave count
    nSlaveCountCfg 				: UINT;			// configured slave count
    nMasterDevState				: WORD;			// device state of EtherCAT Master
    bAllFrameWcStatesOK			: BOOL;			// all FrameWcState OK?
    tTimeout					: TIME := T#5S; // ads timeout
    eSubSystem : E_Subsystem := E_Subsystem.FIELDBUS; // Subsystem, change to (MPS, VACUUM, MOTION, etc)
END_VAR
VAR_OUTPUT
    bEtherCATOK					: BOOL;			// no problem on EtherCAT
    bFrameWcStateError			: BOOL;			// error in at least one frame
    bSlaveCountError			: BOOL;			// EtherCAT slave count mismatch (# of cfg slaves <> # of found slaves)
    bMasterDevStateError		: BOOL;			// error in master device state
    stMasterDevState			: ST_EcMasterDevState; // splitted master device state
    bBusy						: BOOL;			// FB busy
    bError						: BOOL;			// FB with error
    nErrorID					: UDINT;		// FB error ID
END_VAR
VAR_IN_OUT
    astDiagSlaveInfo 			: ARRAY [0..cnEscMaxPorts] OF ST_SlaveStateInfo;		// read in info from configured slaves
    astDiagSlaveInfoScanned		: ARRAY [0..cnEscMaxPorts] OF ST_SlaveStateInfoScanned;	// read in info from scanned slaves
END_VAR
VAR
    eState						: E_EcatDiagState;
    nMasterDevStatePrev			: WORD;
    bSlaveCountErrorPrev		: BOOL;
    bAllFrameWcStatesOKPrev		: BOOL;
    bDiagReq					: BOOL := TRUE;
    nI							: UDINT;
    nP							: UDINT;

    astSlaveInfo 				: ARRAY [0..cnSlaveAddrArrSize] OF ST_SlaveStateInfo;
    stSlaveInfo  :   REFERENCE TO ST_SlaveStateInfo;

    (* -- Get Slave Addresses *)
    fbGetSlaveAddresses 		: FB_EcGetAllSlaveAddr;
    anSlaveAddresses 			: ARRAY[0..cnSlaveAddrArrSize] OF UINT;
    nNumOfSlavesRead			: UINT;

    (* -- Get Slave States *)
    fbGetAllSlaveStates			: FB_EcGetAllSlaveStates;
    astSlaveStates 				: ARRAY[0..cnSlaveAddrArrSize] OF ST_EcSlaveState;

    (* -- Get Topology Data *)
    nTopologyData				: UDINT;
    fbGetTopologyData			: ADSREAD;
    astTopologyData				: ARRAY[0..cnSlaveAddrArrSize] OF ST_TopologyData;

    (* -- Check Topology *)
    anDiagIndex					: ARRAY [0..cnEscMaxPorts] OF UINT;
    nDiagIndex : UINT;
    anDiagPort					: ARRAY [0..cnEscMaxPorts] OF UINT;
    nDiagPort : UINT;
    nIdx						: DINT;

    (* -- Scan Slaves *)
    fbEcGetScannedSlaves		: FB_EcGetScannedSlaves;
    astScannedSlaveInfo			: ARRAY [0..cnSlaveAddrArrSize] OF ST_EcSlaveScannedData; // what...
    rScannedSlaveInfo   :   REFERENCE TO ST_EcSlaveScannedData;
    nScannedSlaves				: UINT;

    (* -- Get Slave Identities *)
    fbGetSlaveIdentity			: FB_EcGetSlaveIdentity;
    stIdentity 					: ST_EcSlaveIdentity;

    (* -- Get Slave Names *)
    fbGetSlaveName 				: IOF_GetBoxNameByAddr;
    astSlaveInfoScanned			: ARRAY [0..cnSlaveAddrArrSize] OF ST_SlaveStateInfoScanned; // the F
    stSlaveInfoScanned   :   REFERENCE TO ST_SlaveStateInfoScanned;
    sStringName						: STRING;



    // Logging components
    fbLogger : FB_LogMessage := (eSubsystem := eSubsystem);

    fbJson : FB_JsonSaxWriter;
    fbJsonDataType : FB_JsonReadWriteDataType;
    stDiagSlaveInfo : REFERENCE TO ST_SlaveStateInfo;
    fbEtherCATOK : F_TRIG;
    fbFrameWcStateError : R_TRIG;
    fbMasterError : R_TRIG;
    nJsonIdx : UINT;
    {attribute 'analysis' := '-27'}
    sTest : T_MaxString;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* cyclic diag *)
bFrameWcStateError := NOT bAllFrameWcStatesOK;

bSlaveCountError := (nSlaveCount <> nSlaveCountCfg) OR (nSlaveCount = 0);
IF (bSlaveCountError AND NOT bSlaveCountErrorPrev) OR (NOT bSlaveCountError AND bSlaveCountErrorPrev) THEN
    bSlaveCountErrorPrev := bSlaveCountError;
    bDiagReq := TRUE; // slave count error change detected --> diag required
END_IF

IF (bAllFrameWcStatesOK AND NOT bAllFrameWcStatesOKPrev) OR (NOT bAllFrameWcStatesOK AND bAllFrameWcStatesOKPrev) THEN
    bAllFrameWcStatesOKPrev := bAllFrameWcStatesOK;
    bDiagReq := TRUE; // frame error change detected --> diag required
END_IF

IF (nMasterDevState <> nMasterDevStatePrev) THEN
    M_CheckMasterDevState();
    bDiagReq := TRUE; // devstate change detected --> diag required
END_IF

(* acyclic diag *)
CASE eState OF
E_EcatDiagState.Idle: (* IDLE *)
    IF bDiagReq THEN				// diag requested
        bDiagReq := FALSE;

        IF sMasterNetID <> '' AND sMasterNetID <> '0.0.0.0.0.0' THEN
            eState := E_EcatDiagState.GetSlaveAddresses;	// execute diag
            bBusy := TRUE;
        ELSE
            bError := TRUE;
            nErrorID := 7;
        END_IF

        bEtherCATOK := FALSE;
    ELSE
        // check for changes in idle
        IF (bSlaveCountError OR bMasterDevStateError OR NOT bAllFrameWcStatesOK) AND NOT (astSlaveInfo[anDiagIndex[0]].bDiagData) THEN
            bEtherCATOK := FALSE;
            bDiagReq := TRUE;//new error --> diag requested
        ELSIF (bSlaveCountError AND NOT bSlaveCountErrorPrev) OR (NOT bSlaveCountError AND bSlaveCountErrorPrev) THEN
            bSlaveCountErrorPrev := bSlaveCountError;
            bEtherCATOK := FALSE;
            bDiagReq := TRUE;// slave count error change detected --> diag required
        ELSIF (nMasterDevState <> nMasterDevStatePrev) THEN
            bEtherCATOK := FALSE;
            bDiagReq := TRUE;// devstate change detected --> diag required
        ELSIF (bAllFrameWcStatesOK AND NOT bAllFrameWcStatesOKPrev) OR (NOT bAllFrameWcStatesOK AND bAllFrameWcStatesOKPrev) THEN
            bAllFrameWcStatesOKPrev := bAllFrameWcStatesOK;
            bEtherCATOK := FALSE;
            bDiagReq := TRUE;// frame error change detected --> diag required
        ELSIF (bSlaveCountError OR bMasterDevStateError OR NOT bAllFrameWcStatesOK OR astSlaveInfo[anDiagIndex[0]].bDiagData) THEN
            bEtherCATOK := FALSE;
        ELSE
            bEtherCATOK := TRUE;
        END_IF
    END_IF

E_EcatDiagState.GetSlaveAddresses: (* get adresses *)
    M_GetSlaveAdresses();

E_EcatDiagState.GetSlaveStates: (* get states *)
    M_GetSlaveStates();

E_EcatDiagState.GetTopoDataLen:	(* get topology data length *)
    M_GetTopoDataLen();

E_EcatDiagState.GetTopoData:	(* get topology data *)
    M_GetTopoData();

E_EcatDiagState.ScanSlaves:	(* scan slaves *)
    M_ScanSlaves();

E_EcatDiagState.GetSlaveIdentity:	(* get identity *)
    M_GetSlaveIdentity();

E_EcatDiagState.GetSlaveName:	(* get name *)
    M_GetSlaveName();

E_EcatDiagState.GetScannedSlaveName:	(* get scanned name *)
    M_GetScannedSlaveName();

E_EcatDiagState.LogDiagnostics: (* Log diagnostics *)
    (* I can't get the fbJsonDataType to actually convert the slave info
    structures. I just get nulls. Either I am doing this wrong, or when
    the symbol parser encounters datatypes it can't deal with it nulls
    the whole thing. I'll keep this code commented out until someone figures
    out how to deal with parsing the slave structs into the json payload *)
    IF nJsonIdx < nNumOfSlavesRead THEN // the last entry is always blank
        nJsonIdx := MIN(cnSlaveAddrArrSize, nJsonIdx);
        stDiagSlaveInfo REF= astSlaveInfo[nJsonIdx];
        DiagnosticJson();
        fbLogger(sMsg:=CONCAT('Diag Results: ', stDiagSlaveInfo.sName),
                eSevr:=TcEventSeverity.Info);
        nJsonIdx := nJsonIdx + 1;
    ELSE
        nJsonIdx := 0;
        eState := E_EcatDiagState.Done;
    END_IF

E_EcatDiagState.Done:	(* DONE *)
    bBusy := FALSE;
    eState := 0;

END_CASE

// Log messages
fbEtherCATOK(CLK:=bEtherCATOK);
IF fbEtherCATOK.Q THEN
    fbLogger(sMsg:='EtherCAT failure, starting diagnostic', eSevr:=TcEventSeverity.Critical, sJson:='');
END_IF

fbFrameWcStateError(CLK:=bFrameWcStateError);
IF fbFrameWcStateError.Q THEN
    fbLogger(sMsg:='Working Counter Frame Error: error in at least one frame', eSevr:=TcEventSeverity.Error, sJson:='');
END_IF

fbMasterError(CLK:=bMasterDevStateError);
IF fbMasterError.Q THEN
    fbJson.StartObject();
        fbJson.AddKey('ecat_master_diag');
        fbJson.StartObject();
            fbJson.AddKey('bAtLeastOneNotInOp');
            fbJson.AddBool(stMasterDevState.bAtLeastOneNotInOp);
            fbJson.AddKey('bDcNotInSync');
            fbJson.AddBool(stMasterDevState.bDcNotInSync);
            fbJson.AddKey('bDriverNotFound');
            fbJson.AddBool(stMasterDevState.bDriverNotFound);
            fbJson.AddKey('bLinkError');
            fbJson.AddBool(stMasterDevState.bLinkError);
            fbJson.AddKey('bMissFrmRedMode');
            fbJson.AddBool(stMasterDevState.bMissFrmRedMode);
            fbJson.AddKey('bResetActive');
            fbJson.AddBool(stMasterDevState.bResetActive);
            fbJson.AddKey('bResetRequired');
            fbJson.AddBool(stMasterDevState.bResetRequired);
            fbJson.AddKey('bWatchdogTriggerd');
            fbJson.AddBool(stMasterDevState.bWatchdogTriggerd);
            fbJson.AddKey('eEcState');
            fbJson.AddUdint(stMasterDevState.eEcState);
        fbJson.EndObject();
    fbJson.EndObject();
    fbJson.CopyDocument(fbLogger.sJson, SIZEOF(fbLogger.sJson));
    fbLogger(sMsg:='Master error: error in master device state', eSevr:=TcEventSeverity.Critical);
    fbJson.ResetDocument();
END_IF
]]></ST>
    </Implementation>
    <Action Name="DiagnosticJson" Id="{0fd17872-19c7-46b0-99a6-f83e877544e3}">
      <Implementation>
        <ST><![CDATA[fbJson.StartObject();
    fbJson.AddKey('ecat_diag');
    fbJson.StartObject();

        fbJson.AddKey('nECAddr');
        fbJson.AddUdint(stDiagSlaveInfo.nECAddr);

        fbJson.AddKey('nIndex');
        fbJson.AddDint(stDiagSlaveInfo.nIndex);

        fbJson.AddKey('sName');
        fbJson.AddString(stDiagSlaveInfo.sName);

        fbJson.AddKey('sType');
        fbJson.AddString(stDiagSlaveInfo.sType);

        fbJson.AddKey('bDiagData');
        fbJson.AddBool(stDiagSlaveInfo.bDiagData);

        fbJson.AddKey('stPortCRCErrors');
        fbjson.StartObject();

            fbJson.AddKey('portA');
            fbJson.AddUdint(stDiagSlaveInfo.stPortCRCErrors.portA);
            fbJson.AddKey('portB');
            fbJson.AddUdint(stDiagSlaveInfo.stPortCRCErrors.portB);
            fbJson.AddKey('portC');
            fbJson.AddUdint(stDiagSlaveInfo.stPortCRCErrors.portC);
            fbJson.AddKey('portD');
            fbJson.AddUdint(stDiagSlaveInfo.stPortCRCErrors.portD);

        fbJson.EndObject();

        fbJson.AddKey('nSumCRCErrors');
        fbjson.AddUdint(stDiagSlaveInfo.nSumCRCErrors);

        fbJson.AddKey('stState');
        fbJson.StartObject();

            fbJson.AddKey('eEcState ');
            fbJson.AddUdint(stDiagSlaveInfo.stState.eEcState);
            fbJson.AddKey('nReserved');
            fbJson.AddUdint(stDiagSlaveInfo.stState.nReserved);
            fbJson.AddKey('bError');
            fbJson.AddBool(stDiagSlaveInfo.stState.bError);
            fbJson.AddKey('bInvalidVPRS');
            fbJson.AddBool(stDiagSlaveInfo.stState.bInvalidVPRS);
            fbJson.AddKey('nReserved2');
            fbJson.AddUdint(stDiagSlaveInfo.stState.nReserved2);
            fbJson.AddKey('bNoCommToSlave');
            fbJson.AddBool(stDiagSlaveInfo.stState.bNoCommToSlave);
            fbJson.AddKey('bLinkError');
            fbJson.AddBool(stDiagSlaveInfo.stState.bLinkError);
            fbJson.AddKey('bMissingLink');
            fbJson.AddBool(stDiagSlaveInfo.stState.bMissingLink);
            fbJson.AddKey('bUnexpectedLink');
            fbJson.AddBool(stDiagSlaveInfo.stState.bUnexpectedLink);
            fbJson.AddKey('bPortA');
            fbJson.AddBool(stDiagSlaveInfo.stState.bPortA);
            fbJson.AddKey('bPortB');
            fbJson.AddBool(stDiagSlaveInfo.stState.bPortB);
            fbJson.AddKey('bPortC');
            fbJson.AddBool(stDiagSlaveInfo.stState.bPortC);
            fbJson.AddKey('bPortD');
            fbJson.AddBool(stDiagSlaveInfo.stState.bPortD);

        fbJson.EndObject();

    fbJson.EndObject();

fbJson.EndObject();

fbJson.CopyDocument(fbLogger.sJson, SIZEOF(fbLogger.sJson));
fbJson.ResetDocument();]]></ST>
      </Implementation>
    </Action>
    <Action Name="M_CheckMasterDevState" Id="{c94efdf2-4838-47e0-bb82-f14b06ccb92e}">
      <Implementation>
        <ST><![CDATA[(* check master errors based on devstate *)
bMasterDevStateError 				:= nMasterDevState <> 0;
stMasterDevState.bLinkError 		:= ((nMasterDevState AND 16#000F) = 1) OR ((nMasterDevState AND 16#000F) = 4);
stMasterDevState.bResetRequired 	:= ((nMasterDevState AND 16#000F) = 2) OR ((nMasterDevState AND 16#FFF0) = 16#10);
stMasterDevState.bMissFrmRedMode 	:= (nMasterDevState AND 16#000F) = 8;
stMasterDevState.bWatchdogTriggerd 	:= (nMasterDevState AND 16#20) = 16#20;
stMasterDevState.bDriverNotFound 	:= (nMasterDevState AND 16#40) = 16#40;
stMasterDevState.bResetActive 		:= (nMasterDevState AND 16#80) = 16#80;
stMasterDevState.bAtLeastOneNotInOp := ((nMasterDevState AND 16#100) = 16#100) OR ((nMasterDevState AND 16#200) = 16#200) OR
                                        ((nMasterDevState AND 16#400) = 16#400) OR ((nMasterDevState AND 16#800) = 16#800);
stMasterDevState.bDcNotInSync 		:= (nMasterDevState AND 16#1000) = 16#1000;
nMasterDevStatePrev 				:= nMasterDevState;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="M_GetScannedSlaveName" Id="{b8516cb6-a50d-4847-8ef9-760658b0a4c9}">
      <Implementation>
        <ST><![CDATA[
stSlaveInfoScanned REF= astSlaveInfoScanned[anDiagIndex[nIdx]];
rScannedSlaveInfo REF= astScannedSlaveInfo[anDiagIndex[nIdx]];

fbGetSlaveName(
    NETID		:= sIPCNetId,
    DEVICEID	:= nMasterDevID,
    BOXADDR		:= rScannedSlaveInfo.nAddr,
    START		:= TRUE,
    TMOUT		:= tTimeout,
    BOXNAME		=> sStringName
);

IF NOT fbGetSlaveName.BUSY THEN
    fbGetSlaveName(START:= FALSE);

    (* add scanned info *)
    stSlaveInfoScanned.nIndex 	:= nDiagIndex + 1;
    IF rScannedSlaveInfo.nAddr <> 0 THEN
        IF NOT fbGetSlaveName.ERR THEN
            stSlaveInfoScanned.sName := sStringName;
        END_IF
    ELSE
        stSlaveInfoScanned.sType		:= '';
    END_IF

    IF (nDiagIndex < nScannedSlaves) THEN
        stSlaveInfoScanned.sType		:= F_ConvProductCodeToString(rScannedSlaveInfo.stSlaveIdentity);
    ELSE
        stSlaveInfoScanned.sType		:= '';
    END_IF

    stSlaveInfoScanned.nECAddr	:= rScannedSlaveInfo.nAddr;

    IF stSlaveInfoScanned.sName <> stSlaveInfo.sName THEN
        stSlaveInfoScanned.bDifferentName := TRUE;
    ELSE
        stSlaveInfoScanned.bDifferentName := FALSE;
    END_IF

    IF stSlaveInfoScanned.nECAddr <> stSlaveInfo.nECAddr THEN
        stSlaveInfoScanned.bDifferentAddr := TRUE;
    ELSE
        stSlaveInfoScanned.bDifferentAddr := FALSE;
    END_IF

    IF stSlaveInfoScanned.sType <> stSlaveInfo.sType THEN
        stSlaveInfoScanned.bDifferentType := TRUE;
    ELSE
        stSlaveInfoScanned.bDifferentType := FALSE;
    END_IF

    IF nIdx < cnEscMaxPorts THEN
        nIdx := nIdx + 1;
        eState := E_EcatDiagState.GetSlaveIdentity; // loop back
    ELSE
        nIdx := 0;
        eState := E_EcatDiagState.LogDiagnostics;

        FOR nI := 0 TO cnEscMaxPorts DO
            IF anDiagPort[nI] <> 0 THEN
                astDiagSlaveInfo[nI] := astSlaveInfo[anDiagIndex[nI]];
                astDiagSlaveInfoScanned[nI] := astSlaveInfoScanned[anDiagIndex[nI]];
            ELSE
                MEMSET(ADR(astDiagSlaveInfo[nI]), 0, SIZEOF(astDiagSlaveInfo[nI]));
                MEMSET(ADR(astDiagSlaveInfoScanned[nI]), 0, SIZEOF(astDiagSlaveInfoScanned[nI]));
            END_IF
        END_FOR
    END_IF
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="M_GetSlaveAdresses" Id="{057b915b-50ee-41a3-b261-5584ed00ac7b}">
      <Implementation>
        <ST><![CDATA[fbGetSlaveAddresses(
    sNetId		:= sMasterNetID,
    pAddrBuf	:= ADR(anSlaveAddresses),
    cbBufLen	:= SIZEOF(anSlaveAddresses),
    bExecute	:= TRUE,
    tTimeout	:= tTimeout,
    nSlaves		=> nNumOfSlavesRead
);

IF NOT fbGetSlaveAddresses.bBusy THEN
    fbGetSlaveAddresses(bExecute:= FALSE);
    IF NOT fbGetSlaveAddresses.bError THEN
        FOR nI := 0 TO MIN(nNumOfSlavesRead, cnSlaveAddrArrSize) DO
            astSlaveInfo[nI].nECAddr := anSlaveAddresses[nI];
        END_FOR
    END_IF
    eState := GetSlaveStates;
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="M_GetSlaveIdentity" Id="{6436ec18-e4f4-4415-8713-025490e22c62}">
      <Implementation>
        <ST><![CDATA[
nDiagIndex := anDiagIndex[nIdx];
nDiagPort := anDiagPort[nIdx];

stSlaveInfo REF= astSlaveInfo[nDiagIndex];

fbGetSlaveIdentity(
    sNetId		:= sMasterNetID,
    nSlaveAddr	:= stSlaveInfo.nECAddr,
    bExecute	:= TRUE,
    tTimeout	:= tTimeout,
    identity	=> stIdentity
);

IF NOT fbGetSlaveIdentity.bBusy THEN
    fbGetSlaveIdentity(bExecute:= FALSE);

    IF NOT fbGetSlaveIdentity.bError THEN
        IF anDiagPort[nIdx] <> 0 THEN
            stSlaveInfo.nIndex	:= anDiagIndex[nIdx] + 1;
            stSlaveInfo.sType 	:= F_ConvProductCodeToString(stSlaveIdentity := stIdentity);
        END_IF
    END_IF
    eState := E_EcatDiagState.GetSlaveName;
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="M_GetSlaveName" Id="{194a1929-ecd0-4768-a413-2484fca7199d}">
      <Implementation>
        <ST><![CDATA[fbGetSlaveName(
    NETID		:= sIPCNetId,
    DEVICEID	:= nMasterDevID,
    BOXADDR		:= stSlaveInfo.nECAddr,
    START		:= TRUE,
    TMOUT		:= tTimeout,
    BOXNAME		=> sStringName
);

IF NOT fbGetSlaveName.BUSY THEN
    fbGetSlaveName(START:= FALSE);

    IF NOT fbGetSlaveName.ERR THEN
        IF nDiagPort <> 0 THEN
            stSlaveInfo.sName 	:= sStringName;
        END_IF
    END_IF

    eState := E_EcatDiagState.GetScannedSlaveName;
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="M_GetSlaveStates" Id="{f2cae496-a223-4599-a971-7399cb288a70}">
      <Implementation>
        <ST><![CDATA[fbGetAllSlaveStates(
    sNetId		:= sMasterNetID,
    pStateBuf	:= ADR(astSlaveStates),
    cbBufLen	:= SIZEOF(astSlaveStates),
    bExecute	:= TRUE,
    tTimeout	:= tTimeout,
    nSlaves		=> nNumOfSlavesRead
);

IF NOT fbGetAllSlaveStates.bBusy THEN
    fbGetAllSlaveStates(bExecute:= FALSE);

    IF NOT fbGetAllSlaveStates.bError THEN
        IF nNumOfSlavesRead = nSlaveCountCfg THEN
            FOR nI := 0 TO cnEscMaxPorts DO
                anDiagIndex[nI] := 0;
            END_FOR

            (* split slave state and link state *)
            FOR nI := 0 TO MIN(nNumOfSlavesRead, cnSlaveAddrArrSize) DO
                (* slave state*)
                astSlaveInfo[nI].stState.eEcState 		:= astSlaveStates[nI].deviceState AND 16#0F;
                astSlaveInfo[nI].stState.bError 			:= astSlaveStates[nI].deviceState.4;
                astSlaveInfo[nI].stState.bInvalidVPRS 	:= astSlaveStates[nI].deviceState.5;
                (* link state *)
                astSlaveInfo[nI].stState.bNoCommToSlave 	:= astSlaveStates[nI].linkState.0;
                astSlaveInfo[nI].stState.bLinkError 		:= astSlaveStates[nI].linkState.1;
                astSlaveInfo[nI].stState.bMissingLink 	:= astSlaveStates[nI].linkState.2;
                astSlaveInfo[nI].stState.bUnexpectedLink := astSlaveStates[nI].linkState.3;
                astSlaveInfo[nI].stState.bPortA 			:= astSlaveStates[nI].linkState.4;
                astSlaveInfo[nI].stState.bPortB 			:= astSlaveStates[nI].linkState.5;
                astSlaveInfo[nI].stState.bPortC 			:= astSlaveStates[nI].linkState.6;
                astSlaveInfo[nI].stState.bPortD 			:= astSlaveStates[nI].linkState.7;
                (* DiagData *)
                astSlaveInfo[nI].bDiagData	:= ((astSlaveStates[nI].deviceState AND 16#F0) <> 0) OR
                    (((astSlaveStates[nI].deviceState AND 16#0F) > 0) AND ((astSlaveStates[nI].deviceState AND 16#0F) < 8)) OR
                    (astSlaveStates[nI].linkState <> 0);

                IF astSlaveInfo[nI].bDiagData THEN
                    IF (nI=0) THEN
                        anDiagIndex[0] := 0;
                    ELSE
                        IF (anDiagIndex[0] = 0) AND NOT astSlaveInfo[0].bDiagData THEN
                            anDiagIndex[0] :=  UDINT_TO_UINT(nI);
                        END_IF
                    END_IF
                END_IF
            END_FOR
        END_IF
    END_IF

    IF astSlaveInfo[anDiagIndex[0]].bDiagData THEN
        eState := E_EcatDiagState.GetTopoDataLen;
    ELSE
        FOR nI := 0 TO cnEscMaxPorts DO
            MEMSET(ADR(astDiagSlaveInfo[nI]), 0, SIZEOF(astDiagSlaveInfo[nI]));
            MEMSET(ADR(astDiagSlaveInfoScanned[nI]), 0, SIZEOF(astDiagSlaveInfoScanned[nI]));
        END_FOR
        eState := E_EcatDiagState.Done;
    END_IF
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="M_GetTopoData" Id="{e190db0a-cd90-44dc-b220-ccd10f73f62c}">
      <Implementation>
        <ST><![CDATA[fbGetTopologyData(
    NETID	:= sMasterNetID,
    PORT	:= 16#FFFF,
    IDXGRP	:= 16#22,
    IDXOFFS	:= 0,
    LEN		:= nTopologyData*SIZEOF(astTopologyData[0]),
    DESTADDR:= ADR(astTopologyData),
    READ	:= TRUE,
    TMOUT	:= tTimeout,
);

IF NOT fbGetTopologyData.BUSY THEN
    fbGetTopologyData(READ := FALSE);

    IF NOT fbGetTopologyData.ERR THEN
        anDiagPort[0] := astTopologyData[anDiagIndex[0]].nOwnPhysicalAddr;
        anDiagPort[1] := astTopologyData[anDiagIndex[0]].stPhysicalAddr.portB;
        anDiagPort[2] := astTopologyData[anDiagIndex[0]].stPhysicalAddr.portC;
        anDiagPort[cnEscMaxPorts] := astTopologyData[anDiagIndex[0]].stPhysicalAddr.portD;

        (* clear diag index  *)
        anDiagIndex[1] := 0;
        anDiagIndex[2] := 0;
        anDiagIndex[cnEscMaxPorts] := 0;

        (* find slaves on PortB-D of first slave with diag *)
        FOR nP := 0 TO cnEscMaxPorts DO
            IF anDiagPort[nP] <> 0 THEN
            FOR nI := 0 TO MIN(nTopologyData-1,cnSlaveAddrArrSize) DO
                IF astTopologyData[nI].nOwnPhysicalAddr = anDiagPort[nP] THEN
                    anDiagIndex[nP] := UDINT_TO_UINT(nI);
                    EXIT;
                END_IF
            END_FOR
        END_IF
        END_FOR
    END_IF

    nIdx := 0;
    eState := E_EcatDiagState.ScanSlaves;
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="M_GetTopoDataLen" Id="{f7465649-3318-44e2-90b8-947c72f47964}">
      <Implementation>
        <ST><![CDATA[fbGetTopologyData(
    NETID	:= sMasterNetID,
    PORT	:= 16#FFFF,
    IDXGRP	:= EC_ADS_IGRP_MASTER_COUNT_SLAVE,
    IDXOFFS	:= EC_ADS_IOFFS_MASTER_COUNT_SLAVE,
    LEN		:= SIZEOF(nTopologyData),
    DESTADDR:= ADR(nTopologyData),
    READ	:= TRUE,
    TMOUT	:= tTimeout,
);

IF NOT fbGetTopologyData.BUSY THEN
    fbGetTopologyData(READ := FALSE);

    eState := E_EcatDiagState.GetTopoData;
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="M_ScanSlaves" Id="{84661742-17c9-4894-a1f9-ed6f9af2c4ee}">
      <Implementation>
        <ST><![CDATA[fbEcGetScannedSlaves(
    bExecute				:= TRUE,
    sNetId					:= sMasterNetID,
    pArrEcScannedSlaveInfo	:= ADR(astScannedSlaveInfo),
    cbBufLen				:= SIZEOF(astScannedSlaveInfo),
    tTimeout				:= tTimeout
);

IF NOT fbEcGetScannedSlaves.bBusy THEN
    fbEcGetScannedSlaves(bExecute := FALSE);

    IF fbEcGetScannedSlaves.bError THEN
        nScannedSlaves := 0;
    ELSE
        nScannedSlaves := fbEcGetScannedSlaves.nSlaves;
    END_IF

    eState := E_EcatDiagState.GetSlaveIdentity;

END_IF
]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>