<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_EcatDiag" Id="{04266cc1-1752-4ae8-b692-47df0663f314}" SpecialFunc="None">
    <Declaration><![CDATA[(*
Ecat bus diagnostic tool
2015-11-4 Alex Wallace
This function block checks the states of all slaves on the ecat bus network,
it could be modified to export the states of the slaves on an individual basis,
but for now it sets the output boolean true if all slaves are OP and false otherwise.
To start the block provide a falling edge on the first pass boolean input.

2018-05-05 Margaret Ghaly
Function block has been modified to retrieve the Device State of the Ethercat Master.
It also exports the states and information of each individual configured Slave.
And saves them in the array q_aEcConfSlaveInfo.
*)
FUNCTION_BLOCK FB_EcatDiag
VAR_INPUT
    {attribute 'naming' := 'omit'}
    I_AMSNetId AT %I* : AMSNETID; //Link to the AMSNETID name in the ethercat master info.
    bFirstPass: BOOL; //Hook to system first pass boolean for proper initialization (must be true for the first cycle of the PLC)
END_VAR
VAR_OUTPUT
    bAllSlaveStatesGood: BOOL; // Set to True if all Slaves are in OP State
    anTermStates: ARRAY[1..256] OF BYTE; //ECAT State of terminals in the bus
    bMasterStateGood:BOOL; // Set to True if the Master Device State is OP
    nMasterState: WORD; // The Device State of the Master
    sMasterState:STRING; //State of the ECAT master
    astEcConfSlaveInfo :  ARRAY[1..256] OF ST_EcDevice; //State of all ECAT slaves in the bus
    nSlaves: UINT; // the Number of the connected Slaves
END_VAR
VAR
    sNetId: T_AmsNetId; //NetId string
    astTermStates: ARRAY[1..256] OF ST_EcSlaveState; //ECAT Slave States Buffer
    astEcConfSlaveInfoLocal: ARRAY[1..256] OF ST_EcSlaveConfigData; //ECAT Slave Configs Buffer
    fbGetAllSlaveStates: FB_EcGetAllSlaveStates; //Acquires the ECAT Slave States puts them into astTermStates

    fbGetMasterState: FB_EcGetMasterState; //Acquires ECAT Master State
    fbGetConfSlaves: FB_EcGetConfSlaves; //Acquires the ECAT slave configuration of the bus (how many, what kind, etc)
    {attribute 'naming' := 'omit'}
    ftReset: F_TRIG; //Reset trigger sensor
    {attribute 'naming' := 'omit'}
    ftMasterReset: F_TRIG; //Retrigger sensor for GetMasterState
    nIterator: INT; //Generic iterator placeholder
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Create the net ID string
sNetId := F_CreateAmsNetId(I_AMSNetId);

//Query the state of all terminals, collect in astTermStates
ftReset(CLK:=fbGetAllSlaveStates.bBusy OR bFirstPass);
fbGetAllSlaveStates.bExecute := ftReset.Q;
fbGetAllSlaveStates(sNetId:=sNetId, pStateBuf := ADR(astTermStates), cbBufLen:=SIZEOF(astTermStates));
//Keep checking...



//Cycle through each entry in the array and check if we have anyone not in OP and that the link state is good.
// If so, then set our global IO bad boolean.
IF fbGetAllSlaveStates.nSlaves > 0 THEN
    bAllSlaveStatesGood := TRUE;
FOR nIterator := 1 TO (UINT_TO_INT(fbGetAllSlaveStates.nSlaves) ) BY 1
    DO
    IF NOT( (astTermStates[nIterator].deviceState = EC_DEVICE_STATE_OP) AND (astTermStates[nIterator].linkState = EC_LINK_STATE_OK)) THEN
        bAllSlaveStatesGood := FALSE;
    END_IF
    anTermStates[nIterator] := astTermStates[nIterator].deviceState;
    astEcConfSlaveInfo[nIterator].nDeviceState :=astTermStates[nIterator].deviceState;//
    astEcConfSlaveInfo[nIterator].nLinkState :=astTermStates[nIterator].linkState;//
    astEcConfSlaveInfo[nIterator].sDeviceState:= F_ConvSlaveStateToString(state:=astTermStates[nIterator]);//

END_FOR
END_IF

// Read the EtherCAT state of the master. If the call is successful,
//the State output variable of type WORD contains the requested status information.
ftMasterReset(CLK:=fbGetMasterState.bBusy OR bFirstPass);
fbGetMasterState(sNetId:= sNetId, bExecute:=ftMasterReset.Q,
                state => nMasterState,bError=>,
                nErrId=>);
bMasterStateGood:= (fbGetMasterState.state = BYTE_TO_UINT(EC_DEVICE_STATE_OP));
sMasterState := F_ConvMasterDevStateToString(fbGetMasterState.state);

//This function is used to read a list of all configured slaves from the EtherCat master object Directory
//needs to run only once
fbGetConfSlaves(bExecute := bFirstPass, sNetId :=sNetId, pArrEcConfSlaveInfo := ADR(astEcConfSlaveInfoLocal),cbBufLen := SIZEOF(astEcConfSlaveInfoLocal));
nSlaves:=fbGetConfSlaves.nSlaves;

IF  NOT (fbGetConfSlaves.bBusy) THEN
    FOR nIterator := 1 TO (UINT_TO_INT(fbGetConfSlaves.nSlaves) ) BY 1
    DO
    astEcConfSlaveInfo[nIterator].nAddrr :=astEcConfSlaveInfoLocal[nIterator].nAddr;
    astEcConfSlaveInfo[nIterator].sName :=astEcConfSlaveInfoLocal[nIterator].sName;
    astEcConfSlaveInfo[nIterator].sType :=astEcConfSlaveInfoLocal[nIterator].sType;
END_FOR
    fbGetConfSlaves.bExecute := FALSE;
END_IF



]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>