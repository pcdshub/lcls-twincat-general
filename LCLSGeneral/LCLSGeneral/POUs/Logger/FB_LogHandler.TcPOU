<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_LogHandler" Id="{3f56ea05-5d12-4cf3-aa32-b1078ff3baf8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_LogHandler
VAR_INPUT

    {attribute 'pytmc' := '
        pv: ADS
    '}
    fbTcAdsListener : FB_Listener;

    {attribute 'pytmc' := '
        pv: Router
    '}
    fbTcRouterListener : FB_Listener;

    {attribute 'pytmc' := '
        pv: RTime
    '}
    fbTcRTimeListener : FB_Listener;

    {attribute 'pytmc' := '
        pv: System
    '}
    fbTcSystemListener : FB_Listener;

    {attribute 'pytmc' := '
        pv: Windows
    '}
    fbWindowsListener : FB_Listener;

    {attribute 'pytmc' := '
        pv: LCLS
    '}
    fbLCLSListener 	: FB_Listener;

END_VAR
VAR_OUTPUT
END_VAR

VAR

    bInitialized	:	BOOL	:= FALSE;
    bReadyToLog		: 	BOOL	:= FALSE;
    fbFirstLog		: 	R_TRIG;

    fbGetHostName 	: FB_GetPLCHostname;
    fbGetIP		 	: FB_GetPLCIPAddress;

    fbListener		:	REFERENCE TO FB_Listener;
    apfbListeners		: 	ARRAY [0..cnNumListeners - 1] OF POINTER TO FB_Listener;

    // Default minimum severity for subscriptions
    eMinSeverity	:	TcEventSeverity := TcEventSeverity.Verbose;

    {attribute 'naming' := 'omit'}
    rtReset				:	R_TRIG; //Reset trigger
    bReset				:	BOOL;

    fbSocket	   		:	FB_ConnectionlessSocket;

    nI					:	UINT;

    bSocketEnable : BOOL;

    fbCtuSocketError : CTU := (PV:=3); // Circuit breaker for socket errors. 3 errors before it stops.

    fbRetryConnection : TON := (PT:=T#1h); // Retry after an hour

    fbTonTrickleBreakerPre : TOF := (PT:=T#1s);
    fbTonTrickleBreaker : TON := (PT := GVL_Logger.ctTrickleTripTime);
    bTripCon : BOOL;
END_VAR

VAR CONSTANT
    cnNumListeners		:	UINT	:= 6;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT bInitialized THEN
    bInitialized := TRUE;
    fbTcAdsListener.Configure(stEventClass:=TC_EVENT_CLASSES.TcGeneralAdsEventClass, eMinSeverity:=eMinSeverity, pfbSocket:=ADR(fbSocket));
    fbTcRouterListener.Configure(stEventClass:=TC_EVENT_CLASSES.TcRouterEventClass, eMinSeverity:=eMinSeverity, pfbSocket:=ADR(fbSocket));
    fbTcRTimeListener.Configure(stEventClass:=TC_EVENT_CLASSES.TcRTimeEventClass, eMinSeverity:=eMinSeverity, pfbSocket:=ADR(fbSocket));
    fbTcSystemListener.Configure(stEventClass:=TC_EVENT_CLASSES.TcSystemEventClass, eMinSeverity:=eMinSeverity, pfbSocket:=ADR(fbSocket));
    fbWindowsListener.Configure(stEventClass:=TC_EVENT_CLASSES.Win32EventClass, eMinSeverity:=eMinSeverity, pfbSocket:=ADR(fbSocket));
    fbLCLSListener.Configure(stEventClass:=TC_EVENT_CLASSES.LCLSGeneralEventClass, eMinSeverity:=eMinSeverity, pfbSocket:=ADR(fbSocket));

    apfbListeners[0] := ADR(fbTcAdsListener);
    apfbListeners[1] := ADR(fbTcRouterListener);
    apfbListeners[2] := ADR(fbTcRTimeListener);
    apfbListeners[3] := ADR(fbTcSystemListener);
    apfbListeners[4] := ADR(fbWindowsListener);
    apfbListeners[5] := ADR(fbLCLSListener);

END_IF

fbGetHostName(
    bEnable := TRUE,
    sHostname => GVL_Logger.sPlcHostname,
);

fbGetIP(
    bEnable := TRUE,
    sIPAddress => fbSocket.sLocalHost
);

(* Ensure the socket is ready for when JSON documents are emitted *)
rtReset(CLK:=bReset);

IF (rtReset.Q AND fbSocket.bEnable) THEN
    fbSocket(bEnable:=FALSE);
END_IF

// Disable fbSocket if too many errors occur
fbCtuSocketError(CU:=fbSocket.bError, RESET:=fbRetryConnection.Q OR rtReset.Q);
bSocketEnable R= fbCtuSocketError.Q;
// Retry an hour later
fbRetryConnection(IN:=fbCtuSocketError.Q);
bSocketEnable S= fbRetryConnection.Q OR rtReset.Q;

fbSocket(
    nLocalPort:=0,
    bEnable:=fbGetIP.bDone,
    nMode:=CONNECT_MODE_ENABLEDBG,
);

bReadyToLog := (
    fbGetHostName.bDone AND
    fbGetIP.bDone AND
    bInitialized AND
    fbSocket.bEnable AND
    NOT fbSocket.bError AND
    fbSocket.eState = E_SocketConnectionlessState.eSOCKET_CREATED
);
fbFirstLog(CLK:=bReadyToLog);

IF fbFirstLog.Q THEN
    fbRootLogger(sMsg:='Logging system online', eSevr:=TcEventSeverity.Info,
                 eSubsystem:=E_Subsystem.NILVALUE);
END_IF

CircuitBreaker();

(* Poke all of the listeners *)
FOR nI := 0 TO cnNumListeners - 1 DO
    fbListener REF= apfbListeners[nI]^;
    fbListener.Execute();
    fbListener.PublishEvents();
END_FOR]]></ST>
    </Implementation>
    <Action Name="CircuitBreaker" Id="{507d90b1-d1d6-4cc3-b632-e6c3c5e13942}">
      <Implementation>
        <ST><![CDATA[// Global log circuit breaker
(*
Logic explanation
We want to trip if there is a constant stream of messages being emitted by this PLC. We also
only want the noisy offenders to trip. To target them we set a global trickle tripped flag
using this logic here. Then each individual FB_LogMessage evaluates itself to see if it's
sending a message too frequently (ie. it's being called to often).

This logic is attempting to implement the following:
1. Trip if the total events exceeds the nTrickleThreshold for >10s
2. Sustain the timer if the event count drops for a handful of cycles since usually a cycle amounts to 10ms, losing a few
should not stop the trickle timer.
*)
bTripCon := GVL_Logger.nGlobAccEvents >0;

fbTonTrickleBreakerPre(IN:=bTripCon);
fbTonTrickleBreaker(IN:=fbTonTrickleBreakerPre.Q);

GVL_Logger.bTrickleTripped S= fbTonTrickleBreaker.Q AND bTripCon;

GVL_Logger.nGlobAccEvents := 0; // reset the count for the next cycle]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>